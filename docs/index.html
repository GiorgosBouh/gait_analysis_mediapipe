<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Clinical Gait Analysis</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #0f172a; --panel: #1e293b; --text: #f1f5f9;
      --accent: #38bdf8; --success: #22c55e; --danger: #ef4444; --warn: #f59e0b;
    }
    body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Inter', sans-serif; overflow: hidden; }
    
    /* Layout: Top Bar, Left Panel (Controls), Right Panel (3D View), Bottom Left (Video) */
    .app-container { display: grid; grid-template-columns: 320px 1fr; grid-template-rows: 60px 1fr; height: 100vh; }
    
    .header { grid-column: 1 / -1; background: var(--panel); border-bottom: 1px solid #334155; display: flex; align-items: center; justify-content: space-between; padding: 0 20px; }
    .header h1 { font-size: 1.2rem; font-weight: 800; color: var(--accent); margin: 0; }
    .status-badge { background: var(--warn); color: #000; padding: 4px 12px; border-radius: 99px; font-weight: 600; font-size: 0.8rem; }

    .sidebar { background: var(--panel); border-right: 1px solid #334155; padding: 20px; display: flex; flex-direction: column; gap: 20px; overflow-y: auto; }
    
    .main-view { position: relative; background: #000; }
    
    /* Video Pip (Picture in Picture) */
    .video-pip {
      position: absolute; bottom: 20px; left: 20px; width: 240px; aspect-ratio: 16/9;
      background: #000; border: 2px solid #334155; border-radius: 8px; overflow: hidden;
      z-index: 10; transition: all 0.3s;
    }
    .video-pip video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
    .video-pip:hover { width: 320px; border-color: var(--accent); }

    /* Controls */
    .section-title { font-size: 0.85rem; text-transform: uppercase; letter-spacing: 1px; color: #94a3b8; margin-bottom: 10px; font-weight: 700; }
    .btn { width: 100%; padding: 12px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: 0.2s; margin-bottom: 8px; }
    .btn-primary { background: var(--accent); color: #0f172a; }
    .btn-primary:hover { background: #0ea5e9; }
    .btn-success { background: var(--success); color: #fff; }
    .btn-danger { background: var(--danger); color: #fff; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }

    .input-group { margin-bottom: 15px; }
    .input-group label { display: block; font-size: 0.9rem; margin-bottom: 5px; color: #cbd5e1; }
    .input-group input { width: 100%; padding: 8px; background: #334155; border: 1px solid #475569; color: white; border-radius: 4px; }

    /* Metrics Overlay on 3D View */
    .metrics-overlay {
      position: absolute; top: 20px; right: 20px; 
      background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(4px);
      padding: 15px; border-radius: 8px; border: 1px solid #334155;
      font-family: monospace; font-size: 0.9rem;
      pointer-events: none;
    }
    .metric-row { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 5px; }
    .val { color: var(--accent); font-weight: bold; }

    /* Loading Overlay */
    #loadingScreen {
      position: fixed; inset: 0; background: var(--bg); z-index: 100;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    .spinner { width: 40px; height: 40px; border: 4px solid var(--accent); border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm"
      }
    }
  </script>
</head>
<body>

  <div id="loadingScreen">
    <div class="spinner"></div>
    <p style="margin-top: 20px;">Loading Scientific 3D Engine...</p>
  </div>

  <div class="app-container">
    <header class="header">
      <div style="display:flex; align-items:center; gap:10px;">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v20M2 12h20"></path></svg>
        <h1>BioGait 3D</h1>
      </div>
      <div id="systemStatus" class="status-badge">INITIALIZING</div>
    </header>

    <aside class="sidebar">
      
      <div>
        <div class="section-title">1. Setup</div>
        <button id="btnCamera" class="btn btn-primary" disabled>Start Camera Preview</button>
        <div class="input-group">
          <label>Subject Height (meters)</label>
          <input type="number" id="inputHeight" value="1.75" step="0.01">
        </div>
      </div>

      <div>
        <div class="section-title">2. Calibration</div>
        <p style="font-size:0.8rem; color:#94a3b8; margin-bottom:10px;">Stand in T-Pose or Neutral. Ensure full body is visible.</p>
        <button id="btnCalibrate" class="btn btn-success" disabled>Capture Static Pose</button>
        <div style="font-size:0.8rem; margin-top:5px;">Scale Factor: <span id="lblScale" style="color:white;">-</span></div>
      </div>

      <div>
        <div class="section-title">3. Acquisition</div>
        <button id="btnRecord" class="btn btn-danger" disabled>Start Gait Recording</button>
        <button id="btnStop" class="btn" style="background:#475569; color:white;" disabled>Stop & Analyze</button>
      </div>

      <div style="margin-top:auto;">
        <button id="btnExport" class="btn btn-primary" disabled>Download 3D CSV Data</button>
      </div>

    </aside>

    <main class="main-view" id="canvasContainer">
      <div class="metrics-overlay" id="metricsOverlay" style="display:none;">
        <div class="metric-row"><span>Cycle:</span> <span class="val" id="valPhase">-</span></div>
        <div class="metric-row"><span>R.Knee Flex:</span> <span class="val" id="valRKnee">0째</span></div>
        <div class="metric-row"><span>L.Knee Flex:</span> <span class="val" id="valLKnee">0째</span></div>
        <div class="metric-row"><span>Step Len (est):</span> <span class="val" id="valStep">0 m</span></div>
      </div>
    </main>

    <div class="video-pip">
      <video id="videoElement" autoplay playsinline muted></video>
    </div>

  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PoseLandmarker, FilesetResolver } from '@mediapipe/tasks-vision';

    // --- CONFIGURATION ---
    // Use FULL model for scientific accuracy (Heavy is too slow for web usually)
    const MODEL_URL = "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task";
    
    // --- STATE MANAGEMENT ---
    const state = {
      isReady: false,
      isCalibrated: false,
      isRecording: false,
      scaleFactor: 1.0, // Multiplier to convert MP Normalized World to Real Meters
      calibrationFrames: [],
      recordedData: [],
      videoSize: { width: 0, height: 0 }
    };

    // --- DOM ELEMENTS ---
    const els = {
      video: document.getElementById('videoElement'),
      container: document.getElementById('canvasContainer'),
      loading: document.getElementById('loadingScreen'),
      status: document.getElementById('systemStatus'),
      btnCam: document.getElementById('btnCamera'),
      btnCal: document.getElementById('btnCalibrate'),
      btnRec: document.getElementById('btnRecord'),
      btnStop: document.getElementById('btnStop'),
      btnExp: document.getElementById('btnExport'),
      lblScale: document.getElementById('lblScale'),
      valPhase: document.getElementById('valPhase'),
      valRKnee: document.getElementById('valRKnee'),
      valLKnee: document.getElementById('valLKnee'),
      valStep: document.getElementById('valStep'),
      metrics: document.getElementById('metricsOverlay'),
      inputHeight: document.getElementById('inputHeight')
    };

    // --- THREE.JS VARIABLES ---
    let scene, camera, renderer, controls, gridHelper;
    const bones = []; 
    const joints = [];
    const SKELETON_CONNECTIONS = [
      [11,12], // Shoulders
      [11,13], [13,15], // Left Arm
      [12,14], [14,16], // Right Arm
      [11,23], [12,24], // Torso sides
      [23,24], // Hips
      [23,25], [25,27], [27,29], [29,31], // Left Leg
      [24,26], [26,28], [28,30], [30,32]  // Right Leg
    ];
    // Color coding: Right = Red/Orange, Left = Blue/Teal, Center = Gray
    const JOINT_COLORS = { left: 0x38bdf8, right: 0xf97316, center: 0xffffff };

    // --- MEDIAPIPE VARIABLES ---
    let poseLandmarker = null;
    let lastVideoTime = -1;
    let rafId = null;

    // --- INITIALIZATION ---
    async function init() {
      initThreeJS();
      await initMediaPipe();
      
      els.loading.style.display = 'none';
      els.status.innerText = "READY";
      els.status.style.background = "#22c55e"; // Green
      els.status.style.color = "#fff";
      els.btnCam.disabled = false;
    }

    function initThreeJS() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0f172a); // Dark Blue-Gray

      // Camera
      camera = new THREE.PerspectiveCamera(50, els.container.clientWidth / els.container.clientHeight, 0.1, 100);
      camera.position.set(0, 1.5, 3.5); // Look from front/slightly up

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(els.container.clientWidth, els.container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      els.container.appendChild(renderer.domElement);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1, 0);
      controls.enableDamping = true;

      // Lighting
      const light = new THREE.DirectionalLight(0xffffff, 2);
      light.position.set(2, 4, 3);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));

      // Floor Grid
      gridHelper = new THREE.GridHelper(4, 20, 0x334155, 0x1e293b);
      scene.add(gridHelper);

      // Skeleton Init
      // 33 Landmarks in MediaPipe Pose
      for (let i = 0; i < 33; i++) {
        const geo = new THREE.SphereGeometry(0.04);
        const mat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.visible = false;
        scene.add(mesh);
        joints.push(mesh);
      }

      // Bones Init
      SKELETON_CONNECTIONS.forEach((conn) => {
        const geo = new THREE.CylinderGeometry(0.02, 0.02, 1, 8);
        const mat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.visible = false;
        scene.add(mesh);
        bones.push({ mesh, start: conn[0], end: conn[1] });
      });

      window.addEventListener('resize', onWindowResize);
      animateThree();
    }

    function onWindowResize() {
      camera.aspect = els.container.clientWidth / els.container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(els.container.clientWidth, els.container.clientHeight);
    }

    function animateThree() {
      requestAnimationFrame(animateThree);
      controls.update();
      renderer.render(scene, camera);
    }

    async function initMediaPipe() {
      try {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm");
        poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: MODEL_URL,
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numPoses: 1
        });
        console.log("MediaPipe Loaded");
      } catch (e) {
        alert("Failed to load AI Model: " + e.message);
      }
    }

    // --- APPLICATION LOGIC ---

    els.btnCam.addEventListener('click', async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
        els.video.srcObject = stream;
        els.video.addEventListener('loadeddata', () => {
          state.isReady = true;
          state.videoSize = { width: els.video.videoWidth, height: els.video.videoHeight };
          els.btnCam.disabled = true;
          els.btnCal.disabled = false;
          els.status.innerText = "PREVIEW MODE";
          els.status.style.background = "#38bdf8"; // Blue
          
          predictLoop();
        });
      } catch (e) {
        alert("Camera access denied.");
      }
    });

    els.btnCal.addEventListener('click', () => {
      state.calibrationFrames = [];
      els.status.innerText = "CALIBRATING...";
      els.status.style.background = "#f59e0b"; // Orange
      
      // Calibrate for 2 seconds (approx 60 frames)
      setTimeout(() => {
        finalizeCalibration();
      }, 2000);
    });

    function finalizeCalibration() {
      if (state.calibrationFrames.length < 10) {
        alert("Calibration failed. Not enough frames. Ensure visibility.");
        els.status.innerText = "PREVIEW MODE";
        return;
      }
      
      // Calculate Median Height in MP Units
      const heights = state.calibrationFrames.sort((a,b) => a - b);
      const medianHeightMP = heights[Math.floor(heights.length / 2)];
      
      const realHeight = parseFloat(els.inputHeight.value);
      state.scaleFactor = realHeight / medianHeightMP;
      state.isCalibrated = true;

      els.lblScale.innerText = state.scaleFactor.toFixed(3);
      els.status.innerText = "CALIBRATED - READY";
      els.status.style.background = "#22c55e"; 
      els.btnCal.disabled = true;
      els.btnRec.disabled = false;
      els.metrics.style.display = 'block';
    }

    els.btnRec.addEventListener('click', () => {
      state.recordedData = [];
      state.isRecording = true;
      els.status.innerText = "RECORDING GAIT";
      els.status.style.background = "#ef4444"; // Red
      els.btnRec.disabled = true;
      els.btnStop.disabled = false;
      els.btnCal.disabled = true;
    });

    els.btnStop.addEventListener('click', () => {
      state.isRecording = false;
      els.status.innerText = "CAPTURED";
      els.status.style.background = "#38bdf8";
      els.btnStop.disabled = true;
      els.btnRec.disabled = false;
      els.btnExport.disabled = false;
    });

    els.btnExport.addEventListener('click', () => {
      if(state.recordedData.length === 0) return;

      let csvContent = "data:text/csv;charset=utf-8,Timestamp_s,Phase,LeftKneeFlexion_deg,RightKneeFlexion_deg,";
      
      // Header for joints (x,y,z)
      for(let i=0; i<33; i++) csvContent += `Joint${i}_X,Joint${i}_Y,Joint${i}_Z,`;
      csvContent += "\n";

      state.recordedData.forEach(row => {
        csvContent += `${row.time.toFixed(3)},${row.phase},${row.lKnee.toFixed(1)},${row.rKnee.toFixed(1)},`;
        row.landmarks.forEach(lm => {
          csvContent += `${lm.x.toFixed(4)},${lm.y.toFixed(4)},${lm.z.toFixed(4)},`;
        });
        csvContent += "\n";
      });

      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", "3d_gait_analysis.csv");
      document.body.appendChild(link);
      link.click();
    });

    // --- MAIN LOOP ---

    async function predictLoop() {
      if (els.video.currentTime !== lastVideoTime) {
        lastVideoTime = els.video.currentTime;
        const startTime = performance.now();
        
        const result = poseLandmarker.detectForVideo(els.video, startTime);

        if (result.worldLandmarks && result.worldLandmarks.length > 0) {
          const landmarks = result.worldLandmarks[0];
          update3DScene(landmarks);
          processGait(landmarks, els.video.currentTime);
        }
      }
      requestAnimationFrame(predictLoop);
    }

    function update3DScene(landmarks) {
      // 1. Update Joints
      for (let i = 0; i < landmarks.length; i++) {
        const lm = landmarks[i];
        if (joints[i]) {
          // MediaPipe coords: Y is down, Z is depth. ThreeJS: Y is up.
          // We Flip Y and Z to match typical 3D world space
          // Also apply Scale Factor if calibrated
          const scale = state.isCalibrated ? state.scaleFactor : 1.0;
          
          joints[i].position.set(lm.x * scale, -lm.y * scale + (state.isCalibrated ? 1.0 : 0), -lm.z * scale);
          joints[i].visible = true;
          
          // Color coding
          if(i % 2 !== 0) joints[i].material.color.setHex(JOINT_COLORS.left); // Left (Odd)
          else joints[i].material.color.setHex(JOINT_COLORS.right); // Right (Even)
          if(i === 0 || (i > 10 && i < 13) || (i > 22 && i < 25)) joints[i].material.color.setHex(JOINT_COLORS.center);
        }
      }

      // 2. Update Bones
      bones.forEach(bone => {
        const start = joints[bone.start].position;
        const end = joints[bone.end].position;
        
        // Position cylinder at midpoint
        bone.mesh.position.copy(start).add(end).multiplyScalar(0.5);
        bone.mesh.lookAt(end);
        bone.mesh.rotateX(Math.PI / 2); // Cylinder default is Y-aligned

        const dist = start.distanceTo(end);
        bone.mesh.scale.set(1, dist, 1);
        bone.mesh.visible = true;
      });
    }

    function processGait(lm, time) {
      // Indexes: 23=L_Hip, 24=R_Hip, 25=L_Knee, 26=R_Knee, 27=L_Ankle, 28=R_Ankle
      
      // 1. Calibration Data Collection
      if (!state.isCalibrated && els.status.innerText === "CALIBRATING...") {
        // Height = Distance from Eye(avg) to Heel(avg) roughly, or just max extent Y
        // MP world landmarks are hip-relative usually. 
        // We approximate full height by (Nose.y - MidAnkle.y)
        const noseY = lm[0].y;
        const ankleY = (lm[27].y + lm[28].y) / 2;
        const heightMP = Math.abs(ankleY - noseY); 
        state.calibrationFrames.push(heightMP);
        return;
      }

      // 2. Real-time Metrics
      const rKneeAngle = calculateAngle3D(lm[24], lm[26], lm[28]);
      const lKneeAngle = calculateAngle3D(lm[23], lm[25], lm[27]);
      
      // Determine Gait Phase (Simple logic based on Foot Height Z/Y relative to other foot)
      // Stance vs Swing
      let phase = "Double Support";
      const lAnkleZ = lm[27].z; // Depth
      const rAnkleZ = lm[28].z;
      
      // Simple heuristic: which foot is forward?
      if (Math.abs(lAnkleZ - rAnkleZ) > 0.1) {
          phase = lAnkleZ < rAnkleZ ? "L. Swing / R. Stance" : "R. Swing / L. Stance";
      }

      // Step Length Est (Distance between ankles in Z plane)
      const scale = state.scaleFactor;
      const stepLen = Math.abs(lm[27].z - lm[28].z) * scale;

      // Update UI
      els.valRKnee.innerText = rKneeAngle.toFixed(0) + "째";
      els.valLKnee.innerText = lKneeAngle.toFixed(0) + "째";
      els.valPhase.innerText = phase;
      els.valStep.innerText = state.isCalibrated ? stepLen.toFixed(2) + " m" : "Uncalib";

      // 3. Recording
      if (state.isRecording) {
        state.recordedData.push({
          time: time,
          phase: phase,
          lKnee: lKneeAngle,
          rKnee: rKneeAngle,
          landmarks: lm.map(p => ({ x: p.x*scale, y: p.y*scale, z: p.z*scale }))
        });
      }
    }

    function calculateAngle3D(a, b, c) {
      // Vector BA
      const v1 = { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
      // Vector BC
      const v2 = { x: c.x - b.x, y: c.y - b.y, z: c.z - b.z };

      // Dot product
      const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
      
      // Magnitudes
      const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);
      const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z);

      // Angle in radians
      const angleRad = Math.acos(dot / (mag1 * mag2));
      // Convert to degrees
      return (180 - (angleRad * (180 / Math.PI))); // 180 - angle because we want flexion (straight leg = 0/180)
    }

    // Start
    init();

  </script>
</body>
</html>